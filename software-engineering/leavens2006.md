<!--
$size: 4:3
$theme: default
page_number: true
*page_number: false
-->

<style>
.author {
  position: absolute;
  right: 0px;
  top: 400px;
  text-align: right;
}
</style>

# Not a Number of Floating Point Problems

G. T. Leavens.:

March 2006, Journal of Object Technology 5(2):75-83.

<div class="author">@tyabu12</div>

---

## 1. (浮動小数点数の) 標準化の背景

多くの言語の浮動小数点数は IEEE 754 標準を採用

---

### NaN

IEEE-754 で定義されている、"未定義" (Not a Number) を表す値

$$0.0/0.0 = NaN$$

$$log(-3.14) = NaN$$

$$x + NaN = NaN$$

---

## 2. NaN に関する問題

### NaN < NaN の結果はどうすべきか？

- 論理値には true か false しかない
- true でも false でもない → 例外機構を使う？
  - しかし例外機構を全ての言語持っているわけではない  
    → 標準には組み込めない

---

### 片側が NaN の場合の比較演算の定義 (IEEE 754)

以下, $\forall x. x \neq NaN$ とする

|式|評価|
|---|---|
|$NaN \neq x$|true|
|$NaN = x$|false|
|$NaN < x$|false|
|$NaN > x$|false|
|$NaN \le x$|false|
|$NaN \ge x$|false|

---

## 形式手法における IEEE 754 の問題点

---

### 等価性が成り立たない

形式手法は数学に基づく

等価性という最も基本的な属性は、 "reflexive" つまり $\forall x. x = x$ をいう

しかし、IEEE 754 が定義する NaN ではこの等価が成り立たない
→ $NaN = NaN$ の評価は false である

---

### 全順序でない

IEEE 754 が定義する NaN では三分律が成り立たない (2つ前のスライド)

>三分律 (trichotomy law) :
>$x < y \lor x = y \lor x > y$ が成り立つこと

この違反は, 浮動小数点数はもはや全順序でないことを意味する

しかし NaN が "Not a Number" であることを考慮すれば, これは理にかなっている (Number は全順序になっている)

問題は, 型システムが NaN を数字と見なしてしまうこと

---

## 3 平均計算プログラムの検証例

- Java と JML を用いた, 浮動小数点数を用いたプログラムの検証例

- NaN による障害をどう取り除きながら, 事前・事後条件をアノテーションしていくかを順を追って解説

  - 基本的には NaN で場合分けしている

- 特に目新しい記述はないので, 省略

---

## 4. NaN の矛盾の解決法

---

### 1. 論理値に第三の値 NaB (Not a Boolean) を許す

メリット

- 全ての値の比較について定義できる

デメリット

- 現在のプログラミング言語や定理証明では一般的ではない

- 全ての型 T に "Not a T" が必要になる
  - 例: `(NaB ? 1 : 2)` の条件式の評価は "Not a Integer"

---

### 2. 言語から NaN を追放する

ビルトイン演算やユーザー定義関数は, NaN を返す代わりに, 例外を投げる

メリット

- 言語の簡潔化
- 整数演算との調和
- プログラマは例外処理に馴染みがある

デメリット

- 効率性の損失

---

### 二案の中間案1. 例外を起こすか NaN を返すかをきりかえる, スイッチ, グローバルパラメータ, オプション

しかし一旦 NaN が言語の一部になったら, NaN 値がたとえ禁じられたとしても考慮する必要がある

結局仕様などの観点から嬉しくない

---

### 二案の中間案2. 値としての NaN は許容するが, 標準の浮動小数点数型には許容しない

Java だと, `double` 型や `float` 型は NaN を含まず, `doubleWithNan` (`double` + NaN) 型や `floatWithNaN` (`float` + NaN) 型を用意する

NaN でないなら, `doubleWithNan` を `double` にキャストすることが可能

前半で述べた反射等価性の欠如問題から, `doubleWithNan` 型には `==` や `!=` 演算を定義しない

---

## 5. 結論

浮動小数点数にかかわる仕様を書く際は, いつも以上に気をつける必要がある (特に値としての NaN の可能性の考慮)

完結で安定したアプローチは, 値としての NaN を使う代わりに例外を投げることである

もし値としての NaN を維持したいなら, 型システムは落とし穴を避けるよう調節することができる

- 結果としてより複雑になるが, 一般的なケースで仕様はかなり簡潔になるだろう
- これは最終的にはプログラマを助け, より信頼できる言語へと至るだろう
